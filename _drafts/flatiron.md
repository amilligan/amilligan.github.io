---
layout: post
title: Learning to software
---

The popularity of accelerated training courses for software has exploded in the past few years, largely in response to the steadily increasing demand for people to fill software development positions, but I think also in response to a desire for a clear career path into professional software development.  Four year college degrees in computer science have not proven to provide the skills needed for development work; many very successful software developers studied something other than computer science, and some haven't completed a college degree.  The absence of an alternative to the traditional four year degree has led to a lot of confusion about what it takes to work effectively in software.

I recently read an [interview](http://blog.thinkful.com/post/52143980897) with Avi Flombaum from the [Flatiron School] (http://flatironschool.com).  One section jumped out at me in particular:

> *Rob*:        Some people have criticized the notion that you can become a developer in 3 months. Some schools are even shorter than that. How do you respond to that? Does 3 months seem like too short a window to make that sort of claim? Or does that seem like an appropriate amount of time?
>
> *Avi*:          I think you become a developer the day you start building something. That happens pretty quickly at Flatiron School. Day 1, they (our students) start building something. After that, they’re a developer, they may not be any good, **but what else does being a developer mean besides building things?**

The final emphasis is mine.  I think many employers who pay the not inconsequential salaries for the developers they hire would want those employees to demonstrate skills beyond "can build things."

> To say that you can’t become a developer in 12 weeks—that’s kind of crazy. To become a great developer, that takes years. But to become an efficient developer, or a productive developer, 8-12 weeks sounds about right.

I think most people would agree it's possible to learn to write software in twelve weeks, just as it's possible to learn to rebuild an engine, play chess, paint with watercolors, or immobilize a dislocated shoulder.  But how long does it take to become a mechanic, a chess master, a painter, or a medical provider?

> Look, what we’re talking about—this isn’t casual—it’s 12 hours a day every day for 12 weeks. It’s like 700 hours of coursework (at Flatiron School). How many Computer Science (CS) classes do you end up actually taking in a 4-year college? 10? And they meet 3 days as week for 2 hours where most of the time you’re sleeping?

I don't know where Avi went to school, but I recall college classes requiring work outside the classroom that totaled quite a lot more than 700 hours.  Notwithstanding this, and that most people take their college classes somewhat more seriously than Avi apparently did, we already know that much of the content of traditional four year computer science degrees has little relevance to professional software development work.  But, what content does a four year computer science degree program lack that an accelerated programming course provides in three months?  If the the accelerated course simply provides the same basics as the college degree program, without the less relevant theoretical topics (and pesky humanities requirements), then it leaves graduates at least equally unprepared for professional development work.

The interesting question is not how existing courses of study fail to provide value, but how proficient software developers actually do learn the skills they have.  When asked, many will tell you that they learned from writing a lot of software and making a lot of mistakes.  In the best of cases a more experienced developer helped to identify and explain their mistakes; in the less ideal cases they simply made the same mistakes over and over before learning the lesson.

Learning from failure is not unprecedented, or even unusual.  After I graduated from college (with a degree in computer science) I shelved my diplomas and worked for a couple years as a street paramedic.  The paramedic school I attended required more than four times the classroom and practical time than the program described by Avi.  Even so, EMS providers know that newly graduated medics are next to useless and pair them with senior medics, often for an internship of a specific length; six months is not uncommon.  The role of the mentor is to identify or anticipate the mentee's mistakes, mitigate or prevent them, and make certain the mentee learns the necessary lessons to prevent them happening again.  The goal of the mentee is to show that he or she can learn these lessons, and become more than useless within an acceptable length of time.  Some, even among those who excelled in the classroom, fail to meet this bar.

At the same time, consider that a paramedic's job, while stressful, is reasonably straightforward.  My job as a medic was not to heal patients but to deliver them to a hospital quickly, dealing with immediately life threatening issues if possible.  A medic's skills and knowledge are narrow and focused: treatment options are limited; patient interactions are measured in minutes; team size is rarely greater than two.  The processes of diagnosis, repair, recovery, maintenance, and (ideally) prevention, some of which are measured in years, all fall to the various members of the medical community with far, far more knowledge and training.

Contrast this with a software project, on which you cannot simply write up your paperwork, hand off to the hospital, and move on.  Developers need not just build things, but build things that will grow, change, and continue to provide value as they do so.  Developers have to work on teams with other developers, without duplication, misunderstanding, or strife.  Developers need to know about existing tools and libraries for solving problems, as well as how to solve problems that have no existing solution, and how to tell the difference.  The opportunities to make mistakes are myriad; I can say with confidence that software developers of all experience take advantage of those opportunities with regularity.

> I don’t think that people who criticize (The Flatiron School) like that are really thinking about it carefully.

I think a lot of people have put a great deal of thought into this, and dismissing their concerns with an ad hominem argument fails to provide a solid defense.

I think it's entirely reasonable to say that the Flatiron School provides value, as do other programs like it.  I think it's entirely reasonable to state that these programs open the door into the software industry.  But, the next question we have to answer is how we provide a path from that open door to productivity and success.  Many more mature professions consider education programs -- whether they result in a degree, a certificate, or a license -- to simply be the first step of training, to be followed by significant time doing real work, with dedicated supervision and evaluation, and an increasing level of autonomy based on performance.  Software developers often take years to learn from mistakes they don't even know they're making, each learning the lessons, or variations thereof, individually.  We can dramatically accelerate this learning with dedicated mentors who identify, prevent, and explain the mistakes as they happen.

Unfortunately, mentoring -- call it internship, apprenticeship, or whatever you like -- requires a significant investment in time and effort.  It also requires a cultural shift; the software industry has to learn to consistently value and reward mentoring abilities such as patience, empathy, and communication as highly as more technical skills.  To this point no entity -- corporate, nonprofit, or governmental -- in the software industry has shouldered this cost (a discussion of responsibility is beyond the scope of this article), but the value of shortening the learning curve from entry-level software developer will greatly outstrip the value of getting more people in the door.

