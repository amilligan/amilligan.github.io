---
layout: post
title: Software mentorship
---

In the past few years, the popularity of accelerated training courses for software has exploded.  While this boom is largely in response to the steadily increasing demand for people to fill software development positions, I think it's also in response to a burgeoning desire for a clear path into professional software development.  Technology companies need more software developers to hire; potential developers need to know what kind of investment a career in technology requires.  Four-year college degrees in computer science have not proven to provide the skills needed for development work; many successful software developers studied subjects other than computer science, and some don't hold any higher education degree.  The absence of a clear alternative to the traditional four-year degree has led to a lot of confusion about what it takes to work effectively in software.

I recently read an [interview](http://blog.thinkful.com/post/52143980897) with Avi Flombaum from the [Flatiron School] (http://flatironschool.com).  One section in particular jumped out at me:

> *Rob*:        Some people have criticized the notion that you can become a developer in 3 months. Some schools are even shorter than that. How do you respond to that? Does 3 months seem like too short a window to make that sort of claim? Or does that seem like an appropriate amount of time?
>
> *Avi*:          I think you become a developer the day you start building something. That happens pretty quickly at Flatiron School. Day 1, they (our students) start building something. After that, they’re a developer, they may not be any good, **but what else does being a developer mean besides building things?**

The final emphasis is mine.  Employers who pay the not inconsequential salaries to hire developers expect those employees to demonstrate skills beyond "can build things."

> To say that you can’t become a developer in 12 weeks—that’s kind of crazy. To become a great developer, that takes years. But to become an efficient developer, or a productive developer, 8-12 weeks sounds about right.

Most people would agree it's possible to learn to write software in twelve weeks -- just as it's possible to learn to rebuild an engine, play chess, paint with watercolors, or immobilize a dislocated shoulder.  But how long does it take to become a mechanic, a chess master, a painter, or a medical provider?

> Look, what we’re talking about—this isn’t casual—it’s 12 hours a day every day for 12 weeks. It’s like 700 hours of coursework (at Flatiron School). How many Computer Science (CS) classes do you end up actually taking in a 4-year college? 10? And they meet 3 days as week for 2 hours where most of the time you’re sleeping?

I don't know where Avi went to school, but my college classes (like most college-level CS coursework) required work outside the classroom that totaled significantly more than 700 hours.  Notwithstanding this qualification --  and that most people take their college classes somewhat more seriously than Avi apparently did -- we already know that much of the content of traditional four-year computer science degrees has little relevance to professional software development work.  The more relevant issue is what content does a four-year computer science degree program lack that an accelerated programming course can provide in only three months?  If the accelerated course simply provides the same basics as the college degree program (without the less relevant theoretical topics and pesky humanities requirements), then it leaves graduates at least equally unprepared for professional development work.

The question is not how existing courses of study fail to provide value, but how proficient software developers actually *do* learn the skills they have.  Many experienced developers will tell you that they learned by writing a lot of software and making a lot of mistakes.  In the best of cases, a more experienced developer helped to identify and explain their mistakes; in the more common cases, they simply made the same mistakes over and over before learning the lesson.

Learning from failure is not unprecedented, or even unusual.  After graduating from college (with a degree in computer science), I shelved my diploma and worked for a couple years as a street paramedic.  The paramedic school I attended required more than four times the classroom and practical time than the program Avi describes.  Regardless, EMS providers know that newly-graduated medics are next to useless, and pair them with senior medics, often for an internship of a specific length: six months is not uncommon.  The mentor's role is to identify or anticipate the mentee's mistakes, mitigate or prevent them, and make certain the mentee learns the necessary lessons to prevent them happening again.  The mentee's goal is to show that he or she can learn these lessons, and become more than useless within an acceptable period of time.  Even among those who excel in the classroom, some fail to meet this bar.

A paramedic's job, while stressful, is reasonably straightforward.  My job as a medic was not to heal patients but to deliver them to a hospital quickly, if possible dealing with any immediately life threatening issues.  A medic's skills and knowledge are narrow and focused: treatment options are limited; patient interactions are measured in minutes; team size is rarely greater than two.  The processes of diagnosis, repair, recovery, maintenance, and (ideally) prevention -- some of which are measured in years -- all fall to the various members of the medical community with far, far more knowledge and training.

Contrast this scenario with a software project on which you cannot simply write up your paperwork, hand off to the hospital, and move on.  Developers need not just build things, but build things that will grow, change, and continue to provide value throughout the process.  Developers have to work on teams with other developers, without duplication, misunderstanding, or strife.  Developers need to know about existing tools and libraries for solving problems, as well as how to solve problems that have no existing solutions -- and how to tell the difference between the two.  The opportunities to make mistakes are myriad; I can say with confidence that software developers of all experience take advantage of those opportunities with regularity.

> I don’t think that people who criticize (The Flatiron School) like that are really thinking about it carefully.

A lot of people have put a great deal of thought into this, and dismissing their concerns with ad hominem reasoning fails to provide a solid argument.

I think it's entirely reasonable to say that the Flatiron School provides value, as do other programs like it.  I think it's entirely reasonable to state that these programs provide a way to open the door into the software industry, although no one has proven whether they offer a more or less effective introduction than more traditional programs.  The real question we have to answer is how we provide a path from that open door to productivity and success.  Many more mature professions consider education programs -- whether they result in a degree, a certificate, or a license -- to simply be the first step of training, to be followed by significant time doing real work, with dedicated supervision and evaluation, and an increasing level of autonomy based on performance.  In contrast, software developers take years to learn from mistakes they don't know they're making, each learning the resulting lessons -- or incompatible variations thereof -- individually.  This is enormously redundant in an profession that frowns deeply on duplication of effort.  We can dramatically improve the efficiency of the learning process with dedicated mentors who identify, prevent, and explain the mistakes as they happen.

Discounting the importance of consistent and meaningful mentorship delays the progression of new developers from beginner to journeyman, slowing the growth of their value to employers, artificially limiting their potential, and generating attrition due to frustration.  The overall ratio of beginning developers to proficient developers defines the average proficiency of the software development industry as a whole.  As the demand for new software developers continues to grow, and as we improve programs for introducing people to professional software development -- in scope and availability as well as effectiveness -- the growth of the ranks of beginners could outpace their progression to proficiency -- some argue we have already crossed this line -- causing an industry-wide drop in development productivity.  No industry can tolerate such a step backward, much less one growing in demand and importance as much as software is now.

