I recently wrote an article about the need for mentorship for novice software developers.  In it, I suggested that four-year computer science degrees don't provide the required skills for development proficiency.  This sparked several lively debates about whether four-year degrees have value.

For the record, I think a four-year college degree has value.  I think the intellectual rigor and discipline required to complete a degree helps to mature a student's thinking, no matter the subject.  I think studying subjects outside computer science helps to further expand a student's intellectual flexibility; some of the my college classes I've used most as a software developer were on psychology and perception.  If nothing else, not everyone who enters the software industry will remain a software developer for their entire career.  Career changes do happen, and require at least a familiarity with a broader range of knowledge that just computer science.

However, more importantly, the debate over the value of four-year computer science programs focused on the value of skills taught in four-year computer science programs: data structures and algorithms, computational analysis, parsing theory, static analysis, CPU architecture, operating systems, network protocols, etc.  I studied these things in school, and I have called upon that knowledge at times in my career.  But, my original argument was not whether software developers need these skills, but how software developers are lacking skills that computer science programs do not, and quite frankly should not, teach.

I for skills and growth in seven distinct areas when I interview, train, evaluate, and work with other software developers.

1) Language fluency

Most people have little trouble learning a programming language.  Most languages have similar concepts and structures: loops, variables, conditionals, numbers and strings.  Telling a computer how to do something is a simple matter of writing the right statements in the right order, and the computer follows the instructions to the letter.  However, programming languages (of which we have hundreds [http://en.wikipedia.org/wiki/List_of_programming_languages]) have nuance and complexity, similar to spoken languages.  A native speaker can easily identify someone who has recently learned to speak their language.  Even if the novice speaker can easily achieve day-to-day tasks in the language, they have limited appreciation of nuance and idiom, which limits their ability to communicate.  Programming languages serve as the mechanism by which we communicate with the computer, but also one way by which we communicate with other developers.  Any limitation in communication limits a developer's effectiveness.

In addition, just as different spoken languages may express concepts differently, different programming languages may have widely different styles and conceptual structure.  Learning multiple programming languages, and understanding their purpose, history, and motivation, can significantly widen a developer's problem solving repertoire.  Experienced developers can generally recognize the common phenomenon code written in one language, but in the style of another language.

2) Engineering

Many people refer generally to software development as "software engineering," given that it is the application of computer science principles to real world problems.

- Machine architecture
- Data structures & algorithms
- Performance

3) Abstraction/design/creativity

4) Project management/client management/leadership

5) Strategic thinking

6) General knowledge
- Security
- REST

7) Humility/patience/empathy/communication

Empathy
We too often focus on the skills that software developers need to interact with computers.  These skills are necessary, but the fact that is that effective software developers interact with people more than with computers.  With extremely rare exceptions, when you work on a software project you will be working with other developers and non-developers, each of whom will have knowledge, abilities, ideas, preferences, needs, pressures, and problems of their own.  You will find yourself in conflict -- major or minor -- with other developers, designers, product managers, clients, and customers.  If you cannot find a way to understand each person's point of view, the value of their contributions, and how they interpret your contributions, you will not contribute effectively as a part of that team.

Communication
You have ideas.  You have a plan.  You cannot execute this plan on your own.  You have to be able to share your ideas with the people with whom you work, and for whom you work, in a way that they can understand.  You may need to explain the same idea to another developer, a product manager, and a customer; each may have a different interpretation of your explanation, so you will have to tailor your message appropriately.  I cannot count the number of projects I have seen go sideways because developers laid out their ideas in technical terms, and then simply wrote off  as stupid anyone who didn't understand.

Even more importantly, those same people with whom you work, and for whom you work, have their own ideas and their own plans.  You have to be able to listen to their ideas and learn to interpret what they believe they are saying, setting aside your 

Patience

